<write_to_file>
<path>frontend/src/store/slices/conversationSlice.ts</path>
<content>
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit'
import { 
  Conversation, 
  Message, 
  ChatState, 
  SendMessageData, 
  ConversationCreateData,
  ConversationFilters,
  SearchOptions,
  AppError,
  TypingIndicatorData 
} from '@/types'
import apiClient from '@/services/api'
import wsManager from '@/services/websocket'

interface ConversationState extends ChatState {
  conversations: Conversation[];
  currentConversation: Conversation | undefined;
  messages: Message[];
  isLoading: boolean;
  isTyping: boolean;
  typingUsers: TypingIndicatorData[];
  hasMoreMessages: boolean;
  isSending: boolean;
  error: AppError | null;
  filters: ConversationFilters;
  searchQuery: string;
  totalConversations: number;
}

const initialState: ConversationState = {
  conversations: [],
  currentConversation: undefined,
  messages: [],
  isLoading: false,
  isTyping: false,
  typingUsers: [],
  hasMoreMessages: true,
  isSending: false,
  error: null,
  filters: {},
  searchQuery: '',
  totalConversations: 0,
}

// Async thunks
export const fetchConversations = createAsyncThunk(
  'conversation/fetchConversations',
  async (params?: { page?: number; limit?: number; filters?: ConversationFilters }) => {
    const response = await apiClient.getConversations({
      page: params?.page || 1,
      limit: params?.limit || 20,
      ...params?.filters,
    })
    return response
  }
)

export const fetchConversation = createAsyncThunk(
  'conversation/fetchConversation',
  async (id: string, { rejectWithValue }) => {
    try {
      const conversation = await apiClient.getConversation(id)
      return conversation
    } catch (error) {
      return rejectWithValue(error)
    }
  }
)

export const createConversation = createAsyncThunk(
  'conversation/createConversation',
  async (data: ConversationCreateData, { rejectWithValue }) => {
    try {
      const conversation = await apiClient.createConversation(data)
      return conversation
    } catch (error) {
      return rejectWithValue(error)
    }
  }
)

export const updateConversation = createAsyncThunk(
  'conversation/updateConversation',
  async ({ id, data }: { id: string; data: Partial<Conversation> }, { rejectWithValue }) => {
    try {
      const conversation = await apiClient.updateConversation(id, data)
      return conversation
    } catch (error) {
      return rejectWithValue(error)
    }
  }
)

export const deleteConversation = createAsyncThunk(
  'conversation/deleteConversation',
  async (id: string, { rejectWithValue }) => {
    try {
      await apiClient.deleteConversation(id)
      return id
    } catch (error) {
      return rejectWithValue(error)
    }
  }
)

export const fetchMessages = createAsyncThunk(
  'conversation/fetchMessages',
  async ({ conversationId, before, after, limit = 50 }: { 
    conversationId: string; 
    before?: string; 
    after?: string; 
    limit?: number 
  }) => {
    const response = await apiClient.getMessages(conversationId, { before, after, limit })
    return { messages: response.data, conversationId, pagination: response.metadata }
  }
)

export const sendMessage = createAsyncThunk(
  'conversation/sendMessage',
  async ({ conversationId, content, contentType }: SendMessageData, { rejectWithValue }) => {
    try {
      const message = await apiClient.sendMessage(conversationId, content, contentType)
      return message
    } catch (error) {
      return rejectWithValue(error)
    }
  }
)

export const updateMessage = createAsyncThunk(
  'conversation/updateMessage',
  async ({ messageId, content }: { messageId: string; content: string }, { rejectWithValue }) => {
    try {
      const message = await apiClient.updateMessage(messageId, content)
      return message
    } catch (error) {
      return rejectWithValue(error)
    }
  }
)

export const deleteMessage = createAsyncThunk(
  'conversation/deleteMessage',
  async (messageId: string, { rejectWithValue }) => {
    try {
      await apiClient.deleteMessage(messageId)
      return messageId
    } catch (error) {
      return rejectWithValue(error)
    }
  }
)

export const markAsRead = createAsyncThunk(
  'conversation/markAsRead',
  async ({ conversationId, messageId }: { conversationId: string; messageId: string }) => {
    await apiClient.markAsRead(conversationId, messageId)
    return { conversationId, messageId }
  }
)

export const searchConversations = createAsyncThunk(
  'conversation/searchConversations',
  async (options: SearchOptions) => {
    // This would be implemented with a search endpoint
    const response = await apiClient.getConversations({
      search: options.query,
      ...options.filters,
      page: options.page,
      limit: options.limit,
    })
    return response
  }
)

const conversationSlice = createSlice({
  name: 'conversation',
  initialState,
  reducers: {
    setCurrentConversation: (state, action: PayloadAction<Conversation | undefined>) => {
      state.currentConversation = action.payload
      if (action.payload) {
        // Join WebSocket room for this conversation
        wsManager.joinConversation(action.payload.id)
      }
    },
    addMessage: (state, action: PayloadAction<Message>) => {
      const message = action.payload
      const existingIndex = state.messages.findIndex(m => m.id === message.id)
      
      if (existingIndex >= 0) {
        // Update existing message
        state.messages[existingIndex] = message
      } else {
        // Add new message and maintain chronological order
        state.messages.push(message)
        state.messages.sort((a, b) => 
          new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
        )
      }
      
      // Update current conversation if this is the active one
      if (state.currentConversation?.id === message.conversation_id) {
        state.currentConversation.last_message_at = message.created_at
        state.currentConversation.last_activity_at = message.created_at
        
        // Update message counts
        if (message.sender_type === 'user') {
          state.currentConversation.user_message_count++
        } else if (message.sender_type === 'ai_agent' || message.sender_type === 'human_agent') {
          state.currentConversation.agent_message_count++
        }
        
        if (message.sender_type === 'ai_agent') {
          state.currentConversation.ai_message_count++
        }
        
        state.currentConversation.message_count++
      }
    },
    updateMessage: (state, action: PayloadAction<Message>) => {
      const message = action.payload
      const index = state.messages.findIndex(m => m.id === message.id)
      if (index >= 0) {
        state.messages[index] = message
      }
    },
    deleteMessage: (state, action: PayloadAction<string>) => {
      const messageId = action.payload
      state.messages = state.messages.filter(m => m.id !== messageId)
    },
    setTypingIndicator: (state, action: PayloadAction<TypingIndicatorData>) => {
      const data = action.payload
      const existingIndex = state.typingUsers.findIndex(
        u => u.conversation_id === data.conversation_id && u.user_id === data.user_id
      )
      
      if (data.is_typing) {
        if (existingIndex >= 0) {
          state.typingUsers[existingIndex] = data
        } else {
          state.typingUsers.push(data)
        }
      } else {
        state.typingUsers = state.typingUsers.filter(
          u => !(u.conversation_id === data.conversation_id && u.user_id === data.user_id)
        )
      }
    },
    setIsTyping: (state, action: PayloadAction<boolean>) => {
      state.isTyping = action.payload
    },
    setFilters: (state, action: PayloadAction<ConversationFilters>) => {
      state.filters = action.payload
    },
    setSearchQuery: (state, action: PayloadAction<string>) => {
      state.searchQuery = action.payload
    },
    clearMessages: (state) => {
      state.messages = []
      state.hasMoreMessages = true
    },
    clearError: (state) => {
      state.error = null
    },
    optimisticMessage: (state, action: PayloadAction<Message>) => {
      // Add message optimistically before server confirmation
      state.messages.push(action.payload)
      state.isSending = true
    },
    removeOptimisticMessage: (state, action: PayloadAction<string>) => {
      // Remove optimistic message when server responds
      state.messages = state.messages.filter(m => m.id !== action.payload)
      state.isSending = false
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch conversations
      .addCase(fetchConversations.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(fetchConversations.fulfilled, (state, action) => {
        state.conversations = action.payload.data
        state.totalConversations = action.payload.metadata.total
        state.isLoading = false
      })
      .addCase(fetchConversations.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as AppError
      })
      // Fetch conversation
      .addCase(fetchConversation.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(fetchConversation.fulfilled, (state, action) => {
        const conversation = action.payload
        // Update in conversations list
        const index = state.conversations.findIndex(c => c.id === conversation.id)
        if (index >= 0) {
          state.conversations[index] = conversation
        } else {
          state.conversations.unshift(conversation)
        }
        state.currentConversation = conversation
        state.isLoading = false
      })
      .addCase(fetchConversation.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as AppError
      })
      // Create conversation
      .addCase(createConversation.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(createConversation.fulfilled, (state, action) => {
        state.conversations.unshift(action.payload)
        state.currentConversation = action.payload
        state.isLoading = false
        // Clear messages for new conversation
        state.messages = []
        state.hasMoreMessages = true
      })
      .addCase(createConversation.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as AppError
      })
      // Update conversation
      .addCase(updateConversation.fulfilled, (state, action) => {
        const updatedConversation = action.payload
        const index = state.conversations.findIndex(c => c.id === updatedConversation.id)
        if (index >= 0) {
          state.conversations[index] = updatedConversation
        }
        if (state.currentConversation?.id === updatedConversation.id) {
          state.currentConversation = updatedConversation
        }
      })
      // Delete conversation
      .addCase(deleteConversation.fulfilled, (state, action) => {
        const conversationId = action.payload
        state.conversations = state.conversations.filter(c => c.id !== conversationId)
        if (state.currentConversation?.id === conversationId) {
          state.currentConversation = undefined
          state.messages = []
          state.hasMoreMessages = true
        }
      })
      // Fetch messages
      .addCase(fetchMessages.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(fetchMessages.fulfilled, (state, action) => {
        const { messages, pagination } = action.payload
        
        if (pagination.page === 1) {
          // First page or refresh - replace messages
          state.messages = messages
        } else {
          // Load more - append messages
          const existingIds = new Set(state.messages.map(m => m.id))
          const newMessages = messages.filter(m => !existingIds.has(m.id))
          state.messages = [...state.messages, ...newMessages]
          // Sort by created_at to maintain chronological order
          state.messages.sort((a, b) => 
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
          )
        }
        
        state.hasMoreMessages = pagination.has_next || false
        state.isLoading = false
      })
      .addCase(fetchMessages.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as AppError
      })
      // Send message
      .addCase(sendMessage.pending, (state) => {
        state.isSending = true
        state.error = null
      })
      .addCase(sendMessage.fulfilled, (state, action) => {
        // Replace optimistic message with real one
        const sentMessage = action.payload
        const index = state.messages.findIndex(m => m.id === sentMessage.id)
        if (index >= 0) {
          state.messages[index] = sentMessage
        } else {
          state.messages.push(sentMessage)
          state.messages.sort((a, b) => 
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
          )
        }
        state.isSending = false
        
        // Update current conversation
        if (state.currentConversation?.id === sentMessage.conversation_id) {
          state.currentConversation.last_message_at = sentMessage.created_at
          state.currentConversation.last_activity_at = sentMessage.created_at
        }
      })
      .addCase(sendMessage.rejected, (state, action) => {
        state.isSending = false
        state.error = action.payload as AppError
        // Remove optimistic message on failure
        if (action.meta.arg) {
          state.messages = state.messages.filter(m => m.id !== action.meta.arg.id)
        }
      })
      // Update message
      .addCase(updateMessage.fulfilled, (state, action) => {
        const updatedMessage = action.payload
        const index = state.messages.findIndex(m => m.id === updatedMessage.id)
        if (index >= 0) {
          state.messages[index] = updatedMessage
        }
      })
      // Delete message
      .addCase(deleteMessage.fulfilled, (state, action) => {
        const messageId = action.payload
        state.messages = state.messages.filter(m => m.id !== messageId)
      })
      // Mark as read
      .addCase(markAsRead.fulfilled, (state, action) => {
        const { messageId } = action.payload
        const message = state.messages.find(m => m.id === messageId)
        if (message) {
          message.seen_at = new Date().toISOString()
        }
      })
      // Search conversations
      .addCase(searchConversations.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(searchConversations.fulfilled, (state, action) => {
        state.conversations = action.payload.data
        state.totalConversations = action.payload.metadata.total
        state.isLoading = false
      })
      .addCase(searchConversations.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as AppError
      })
  },
})

export const {
  setCurrentConversation,
  addMessage,
  updateMessage,
  deleteMessage,
  setTypingIndicator,
  setIsTyping,
  setFilters,
  setSearchQuery,
  clearMessages,
  clearError,
  optimisticMessage,
  removeOptimisticMessage,
} = conversationSlice.actions

// Selectors
export const selectConversations = (state: { conversation: ConversationState }) => state.conversation.conversations
export const selectCurrentConversation = (state: { conversation: ConversationState }) => state.conversation.currentConversation
export const selectMessages = (state: { conversation: ConversationState }) => state.conversation.messages
export const selectIsLoading = (state: { conversation: ConversationState }) => state.conversation.isLoading
export const selectIsSending = (state: { conversation: ConversationState }) => state.conversation.isSending
export const selectIsTyping = (state: { conversation: ConversationState }) => state.conversation.isTyping
export const selectTypingUsers = (state: { conversation: ConversationState }) => state.conversation.typingUsers
export const selectHasMoreMessages = (state: { conversation: ConversationState }) => state.conversation.hasMoreMessages
export const selectConversationError = (state: { conversation: ConversationState }) => state.conversation.error
export const selectFilters = (state: { conversation: ConversationState }) => state.conversation.filters
export const selectSearchQuery = (state: { conversation: ConversationState }) => state.conversation.searchQuery
export const selectTotalConversations = (state: { conversation: ConversationState }) => state.conversation.totalConversations

// Memoized selectors
export const selectUnreadCount = (state: { conversation: ConversationState }) => {
  return state.conversation.conversations.filter(c => 
    c.status === 'active' && c.last_message_at && c.last_message_at > (state.conversation.currentConversation?.last_read_at || '')
  ).length
}

export const selectActiveConversations = (state: { conversation: ConversationState }) => {
  return state.conversation.conversations.filter(c => 
    c.status === 'active' || c.status === 'waiting_for_user' || c.status === 'processing'
  )
}

export const selectConversationsByStatus = (status: ConversationStatus) => 
  (state: { conversation: ConversationState }) => {
    return state.conversation.conversations.filter(c => c.status === status)
  }

export const selectMessagesByConversation = (conversationId: string) => 
  (state: { conversation: ConversationState }) => {
    return state.conversation.messages.filter(m => m.conversation_id === conversationId)
  }

export const selectLastMessage = (state: { conversation: ConversationState }) => {
  return state.conversation.messages[state.conversation.messages.length - 1]
}

export default conversationSlice.reducer
</content>
</write_to_file>

<write_to_file>
<path>frontend/src/store/slices/uiSlice.ts</path>
<content>
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import { UIState, Notification, A11yPreferences } from '@/types'

interface UIStateExtended extends UIState {
  sidebarOpen: boolean;
  mobileMenuOpen: boolean;
  modalStack: string[];
  toastQueue: Notification[];
  isScrolling: boolean;
  scrollPosition: number;
  viewportSize: {
    width: number;
    height: number;
    isMobile: boolean;
    isTablet: boolean;
    isDesktop: boolean;
  };
  connectionStatus: 'online' | 'offline' | 'connecting';
  performanceMode: 'high' | 'balanced' | 'low';
}

const initialState: UIStateExtended = {
  theme: 'light',
  language: 'en',
  rtl: false,
  sidebarOpen: false,
  mobileMenuOpen: false,
  notifications: [],
  loading: false,
  error: null,
  modalStack: [],
  toastQueue: [],
  isScrolling: false,
  scrollPosition: 0,
  viewportSize: {
    width: typeof window !== 'undefined' ? window.innerWidth : 1200,
    height: typeof window !== 'undefined' ? window.innerHeight : 800,
    isMobile: false,
    isTablet: false,
    isDesktop: true,
  },
  connectionStatus: 'online',
  performanceMode: 'balanced',
  accessibility: {
    reducedMotion: false,
    highContrast: false,
    largeText: false,
    screenReaderOptimized: false,
    keyboardNavigation: false,
    focusIndicators: true,
  },
}

const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    setTheme: (state, action: PayloadAction<'light' | 'dark' | 'auto'>) => {
      state.theme = action.payload
      // Apply theme to document
      if (typeof document !== 'undefined') {
        document.documentElement.classList.remove('light', 'dark')
        if (action.payload === 'auto') {
          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
          document.documentElement.classList.add(prefersDark ? 'dark' : 'light')
        } else {
          document.documentElement.classList.add(action.payload)
        }
      }
    },
    setLanguage: (state, action: PayloadAction<string>) => {
      state.language = action.payload
      // Set RTL based on language
      const rtlLanguages = ['ar', 'he', 'fa', 'ur']
      state.rtl = rtlLanguages.includes(action.payload)
      
      // Apply RTL to document
      if (typeof document !== 'undefined') {
        document.documentElement.setAttribute('lang', action.payload)
        document.documentElement.setAttribute('dir', state.rtl ? 'rtl' : 'ltr')
      }
    },
    setSidebarOpen: (state, action: PayloadAction<boolean>) => {
      state.sidebarOpen = action.payload
    },
    setMobileMenuOpen: (state, action: PayloadAction<boolean>) => {
      state.mobileMenuOpen = action.payload
    },
    toggleSidebar: (state) => {
      state.sidebarOpen = !state.sidebarOpen
    },
    toggleMobileMenu: (state) => {
      state.mobileMenuOpen = !state.mobileMenuOpen
    },
    addNotification: (state, action: PayloadAction<Notification>) => {
      state.notifications.unshift(action.payload)
      // Limit notifications to prevent memory issues
      if (state.notifications.length > 50) {
        state.notifications = state.notifications.slice(0, 50)
      }
    },
    removeNotification: (state, action: PayloadAction<string>) => {
      state.notifications = state.notifications.filter(n => n.id !== action.payload)
    },
    markNotificationAsRead: (state, action: PayloadAction<string>) => {
      const notification = state.notifications.find(n => n.id === action.payload)
      if (notification) {
        notification.read = true
      }
    },
    markAllNotificationsAsRead: (state) => {
      state.notifications.forEach(n => n.read = true)
    },
    clearNotifications: (state) => {
      state.notifications = []
    },
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload
    },
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload
    },
    clearError: (state) => {
      state.error = null
    },
    pushModal: (state, action: PayloadAction<string>) => {
      state.modalStack.push(action.payload)
    },
    popModal: (state) => {
      state.modalStack.pop()
    },
    clearModals: (state) => {
      state.modalStack = []
    },
    setScrollPosition: (state, action: PayloadAction<number>) => {
      state.scrollPosition = action.payload
    },
    setIsScrolling: (state, action: PayloadAction<boolean>) => {
      state.isScrolling = action.payload
    },
    setViewportSize: (state, action: PayloadAction<{ width: number; height: number }>) => {
      const { width, height } = action.payload
      state.viewportSize = {
        width,
        height,
        isMobile: width < 768,
        isTablet: width >= 768 && width < 1024,
        isDesktop: width >= 1024,
      }
    },
    setConnectionStatus: (state, action: PayloadAction<'online' | 'offline' | 'connecting'>) => {
      state.connectionStatus = action.payload
    },
    setPerformanceMode: (state, action: PayloadAction<'high' | 'balanced' | 'low'>) => {
      state.performanceMode = action.payload
    },
    setAccessibilityPreference: (state, action: PayloadAction<Partial<A11yPreferences>>) => {
      state.accessibility = { ...state.accessibility, ...action.payload }
      
      // Apply accessibility preferences
      if (typeof document !== 'undefined') {
        // Reduced motion
        if (action.payload.reducedMotion !== undefined) {
          document.documentElement.style.setProperty(
            'scroll-behavior', 
            action.payload.reducedMotion ? 'auto' : 'smooth'
          )
        }
        
        // High contrast
        if (action.payload.highContrast !== undefined) {
          document.documentElement.classList.toggle('high-contrast', action.payload.highContrast)
        }
        
        // Large text
        if (action.payload.largeText !== undefined) {
          document.documentElement.classList.toggle('large-text', action.payload.largeText)
        }
        
        // Focus indicators
        if (action.payload.focusIndicators !== undefined) {
          document.documentElement.classList.toggle('focus-visible', action.payload.focusIndicators)
        }
      }
    },
    toggleAccessibilityPreference: (state, action: PayloadAction<keyof A11yPreferences>) => {
      const key = action.payload
      state.accessibility[key] = !state.accessibility[key]
      
      // Apply the change immediately
      if (typeof document !== 'undefined') {
        switch (key) {
          case 'reducedMotion':
            document.documentElement.style.setProperty(
              'scroll-behavior', 
              state.accessibility.reducedMotion ? 'auto' : 'smooth'
            )
            break
          case 'highContrast':
            document.documentElement.classList.toggle('high-contrast', state.accessibility.highContrast)
            break
          case 'largeText':
            document.documentElement.classList.toggle('large-text', state.accessibility.largeText)
            break
          case 'focusIndicators':
            document.documentElement.classList.toggle('focus-visible', state.accessibility.focusIndicators)
            break
        }
      }
    },
    queueToast: (state, action: PayloadAction<Notification>) => {
      state.toastQueue.push(action.payload)
    },
    dequeueToast: (state) => {
      state.toastQueue.shift()
    },
    clearToastQueue: (state) => {
      state.toastQueue = []
    },
  },
})

// Actions
export const {
  setTheme,
  setLanguage,
  setSidebarOpen,
  setMobileMenuOpen,
  toggleSidebar,
  toggleMobileMenu,
  addNotification,
  removeNotification,
  markNotificationAsRead,
  markAllNotificationsAsRead,
  clearNotifications,
  setLoading,
  setError,
  clearError,
  pushModal,
  popModal,
  clearModals,
  setScrollPosition,
  setIsScrolling,
  setViewportSize,
  setConnectionStatus,
  setPerformanceMode,
  setAccessibilityPreference,
  toggleAccessibilityPreference,
  queueToast,
  dequeueToast,
  clearToastQueue,
} = uiSlice.actions

// Selectors
export const selectTheme = (state: { ui: UIStateExtended }) => state.ui.theme
export const selectLanguage = (state: { ui: UIStateExtended }) => state.ui.language
export const selectRtl = (state: { ui: UIStateExtended }) => state.ui.rtl
export const selectSidebarOpen = (state: { ui: UIStateExtended }) => state.ui.sidebarOpen
export const selectMobileMenuOpen = (state: { ui: UIStateExtended }) => state.ui.mobileMenuOpen
export const selectNotifications = (state: { ui: UIStateExtended }) => state.ui.notifications
export const selectUnreadNotifications = (state: { ui: UIStateExtended }) => 
  state.ui.notifications.filter(n => !n.read)
export const selectIsLoading = (state: { ui: UIStateExtended }) => state.ui.loading
export const selectError = (state: { ui: UIStateExtended }) => state.ui.error
export const selectModalStack = (state: { ui: UIStateExtended }) => state.ui.modalStack
export const selectViewportSize = (state: { ui: UIStateExtended }) => state.ui.viewportSize
export const selectIsMobile = (state: { ui: UIStateExtended }) => state.ui.viewportSize.isMobile
export const selectConnectionStatus = (state: { ui: UIStateExtended }) => state.ui.connectionStatus
export const selectPerformanceMode = (state: { ui: UIStateExtended }) => state.ui.performanceMode
export const selectAccessibility = (state: { ui: UIStateExtended }) => state.ui.accessibility
export const selectToastQueue = (state: { ui: UIStateExtended }) => state.ui.toastQueue

// Memoized selectors
export const selectHasActiveModal = (state: { ui: UIStateExtended }) => state.ui.modalStack.length > 0
export const selectTopModal = (state: { ui: UIStateExtended }) => state.ui.modalStack[state.ui.modalStack.length - 1]
export const selectNotificationCount = (state: { ui: UIStateExtended }) => state.ui.notifications.length
export const selectUnreadNotificationCount = (state: { ui: UIStateExtended }) => 
  state.ui.notifications.filter(n => !n.read).length

export default uiSlice.reducer
</content>
</write_to_file>

### Step 5: Core Chat Hook Implementation

<write_to_file>
<path>frontend/src/hooks/useChat.ts</path>
<content>
import { useState, useCallback, useEffect, useRef } from 'react'
import { useAppDispatch, useAppSelector } from '@/store'
import { 
  sendMessage, 
  fetchMessages, 
  updateMessage,
  deleteMessage,
  markAsRead,
  setCurrentConversation,
  addMessage,
  optimisticMessage,
  removeOptimisticMessage,
  selectCurrentConversation,
  selectMessages,
  selectIsSending,
  selectIsTyping,
  selectTypingUsers 
} from '@/store/slices/conversationSlice'
import { 
  Message, 
  SendMessageData, 
  Conversation,
  MessageContentType,
  ConversationStatus 
} from '@/types'
import wsManager from '@/services/websocket'
import { v4 as uuidv4 } from 'uuid'

interface UseChatOptions {
  conversationId?: string;
  autoScroll?: boolean;
  markAsReadOnVisible?: boolean;
  enableTyping?: boolean;
  typingDelay?: number;
}

interface UseChatReturn {
  // State
  messages: Message[];
  currentConversation: Conversation | undefined;
  isSending: boolean;
  isTyping: boolean;
  typingUsers: Array<{
    user_id?: string;
    user_name?: string;
    is_typing: boolean;
    timestamp: string;
  }>;
  
  // Actions
  sendMessage: (content: string, contentType?: MessageContentType) => Promise<void>;
  editMessage: (messageId: string, newContent: string) => Promise<void>;
  deleteMessage: (messageId: string) => Promise<void>;
  loadMoreMessages: () => Promise<void>;
  markMessagesAsRead: (messageIds: string[]) => Promise<void>;
  setCurrentConversation: (conversation: Conversation | undefined) => void;
  
  // Typing
  startTyping: () => void;
  stopTyping: () => void;
  
  // Optimistic updates
  addOptimisticMessage: (content: string) => Message;
  
  // UI helpers
  scrollToBottom: () => void;
  scrollToMessage: (messageId: string) => void;
  
  // Error handling
  error: string | null;
  clearError: () => void;
}

export function useChat(options: UseChatOptions = {}): UseChatReturn {
  const {
    conversationId,
    autoScroll = true,
    markAsReadOnVisible = true,
    enableTyping = true,
    typingDelay = 1000,
  } = options

  const dispatch = useAppDispatch()
  const messages = useAppSelector(selectMessages)
  const currentConversation = useAppSelector(selectCurrentConversation)
  const isSending = useAppSelector(selectIsSending)
  const isTyping = useAppSelector(selectIsTyping)
  const typingUsers = useAppSelector(selectTypingUsers)
  const [error, setError] = useState<string | null>(null)
  
  // Refs for managing side effects
  const scrollContainerRef = useRef<HTMLDivElement | null>(null)
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const intersectionObserverRef = useRef<IntersectionObserver | null>(null)
  const lastReadMessageRef = useRef<string | null>(null)

  // Initialize conversation if ID provided
  useEffect(() => {
    if (conversationId && (!currentConversation || currentConversation.id !== conversationId)) {
      dispatch(fetchConversation(conversationId))
    }
  }, [conversationId, dispatch, currentConversation])

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (autoScroll && messages.length > 0) {
      scrollToBottom()
    }
  }, [messages.length, autoScroll])

  // Setup WebSocket listeners for real-time updates
  useEffect(() => {
    if (currentConversation?.id) {
      // Join conversation room
      wsManager.joinConversation(currentConversation.id)
      
      // Setup typing indicators
      if (enableTyping) {
        wsManager.requestNotificationPermission()
      }
    }

    return () => {
      if (currentConversation?.id) {
        wsManager.leaveConversation(currentConversation.id)
      }
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current)
      }
      if (intersectionObserverRef.current) {
        intersectionObserverRef.current.disconnect()
      }
    }
  }, [currentConversation?.id, enableTyping])

  // Setup intersection observer for marking messages as read
  useEffect(() => {
    if (!markAsReadOnVisible || !currentConversation?.id) return

    intersectionObserverRef.current = new IntersectionObserver(
      (entries) => {
        const visibleMessages = entries
          .filter(entry => entry.isIntersecting)
          .map(entry => entry.target.getAttribute('data-message-id'))
          .filter(Boolean) as string[]

        if (visibleMessages.length > 0) {
          markMessagesAsRead(visibleMessages)
        }
      },
      {
        threshold: 0.5, // Message is 50% visible
        rootMargin: '0px 0px -100px 0px', // Account for input area
      }
    )

    return () => {
      if (intersectionObserverRef.current) {
        intersectionObserverRef.current.disconnect()
      }
    }
  }, [markAsReadOnVisible, currentConversation?.id])

  // Observe messages for read receipts
  useEffect(() => {
    if (!intersectionObserverRef.current) return

    // Clear previous observations
    intersectionObserverRef.current.disconnect()

    // Observe all unread messages from other users
    const unreadMessages = messages.filter(
      msg => 
        msg.conversation_id === currentConversation?.id &&
        msg.sender_type !== 'user' && 
        !msg.seen_at &&
        msg.id !== lastReadMessageRef.current
    )

    unreadMessages.forEach(message => {
      const element = document.querySelector(`[data-message-id="${message.id}"]`)
      if (element) {
        intersectionObserverRef.current?.observe(element)
      }
    })
  }, [messages, currentConversation?.id])

  const handleSendMessage = useCallback(async (
    content: string, 
    contentType: MessageContentType = 'text'
  ): Promise<void> => {
    if (!currentConversation?.id || !content.trim()) {
      return
    }

    try {
      setError(null)
      
      // Create optimistic message
      const optimisticMsg = addOptimisticMessage(content)
      
      // Send through WebSocket for real-time experience
      wsManager.sendMessage(currentConversation.id, content)
      
      // Send through API for persistence
      await dispatch(sendMessage({ 
        conversationId: currentConversation.id, 
        content, 
        contentType 
      })).unwrap()
      
      // Remove optimistic message on success
      dispatch(removeOptimisticMessage(optimisticMsg.id))
      
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to send message')
      // Remove optimistic message on failure
      dispatch(removeOptimisticMessage(optimisticMsg.id))
      throw err
    }
  }, [currentConversation?.id, dispatch])

  const handleEditMessage = useCallback(async (
    messageId: string, 
    newContent: string
  ): Promise<void> => {
    try {
      setError(null)
      await dispatch(updateMessage({ messageId, content: newContent })).unwrap()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to edit message')
      throw err
    }
  }, [dispatch])

  const handleDeleteMessage = useCallback(async (
    messageId: string
  ): Promise<void> => {
    try {
      setError(null)
      await dispatch(deleteMessage(messageId)).unwrap()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete message')
      throw err
    }
  }, [dispatch])

  const handleLoadMoreMessages = useCallback(async (): Promise<void> => {
    if (!currentConversation?.id || !hasMoreMessages || isLoading) {
      return
    }

    try {
      setError(null)
      const oldestMessage = messages[0]
      await dispatch(fetchMessages({ 
        conversationId: currentConversation.id, 
        before: oldestMessage?.created_at,
        limit: 50 
      })).unwrap()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load more messages')
      throw err
    }
  }, [currentConversation?.id, messages, hasMoreMessages, isLoading, dispatch])

  const handleMarkMessagesAsRead = useCallback(async (
    messageIds: string[]
  ): Promise<void> => {
    if (!currentConversation?.id) {
      return
    }

    try {
      setError(null)
      // Mark the last message as read (backend will handle the rest)
      const lastMessageId = messageIds[messageIds.length - 1]
      if (lastMessageId && lastMessageId !== lastReadMessageRef.current) {
        lastReadMessageRef.current = lastMessageId
        await dispatch(markAsRead({ 
          conversationId: currentConversation.id, 
          messageId: lastMessageId 
        })).unwrap()
      }
    } catch (err) {
      console.error('Failed to mark messages as read:', err)
      // Don't show error to user for read receipts
    }
  }, [currentConversation?.id, dispatch])

  const handleSetCurrentConversation = useCallback((
    conversation: Conversation | undefined
  ): void => {
    dispatch(setCurrentConversation(conversation))
  }, [dispatch])

  const handleStartTyping = useCallback((): void => {
    if (!enableTyping || !currentConversation?.id || isTyping) {
      return
    }

    // Set local typing state
    dispatch(setIsTyping(true))
    
    // Send typing indicator via WebSocket
    wsManager.sendTypingStart(currentConversation.id)
    
    // Clear typing indicator after delay
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current)
    }
    
    typingTimeoutRef.current = setTimeout(() => {
      handleStopTyping()
    }, typingDelay)
  }, [enableTyping, currentConversation?.id, isTyping, typingDelay, dispatch])

  const handleStopTyping = useCallback((): void => {
    if (!currentConversation?.id) {
      return
    }

    // Clear local typing state
    dispatch(setIsTyping(false))
    
    // Send typing stop via WebSocket
    wsManager.sendTypingStop(currentConversation.id)
    
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current)
      typingTimeoutRef.current = null
    }
  }, [currentConversation?.id, dispatch])

  const addOptimisticMessage = useCallback((
    content: string
  ): Message => {
    const optimisticMessage: Message = {
      id: `optimistic-${uuidv4()}`,
      conversation_id: currentConversation?.id || '',
      organization_id: currentConversation?.organization_id || '',
      sender_type: 'user',
      sender_id: '', // Will be populated by backend
      content,
      content_type: 'text',
      content_encrypted: false,
      ai_processed: false,
      is_flagged: false,
      is_internal: false,
      is_automated: false,
      is_system_generated: false,
      is_private: false,
      is_edited: false,
      edit_count: 0,
      has_attachments: false,
      attachments: [],
      failed_delivery: false,
      delivery_attempts: 0,
      entities: [],
      keywords: [],
      topics: [],
      metadata: {},
      created_at: new Date().toISOString(),
    }
    
    dispatch(optimisticMessage(optimisticMessage))
    return optimisticMessage
  }, [currentConversation, dispatch])

  const scrollToBottom = useCallback((): void => {
    if (scrollContainerRef.current) {
      scrollContainerRef.current.scrollTo({
        top: scrollContainerRef.current.scrollHeight,
        behavior: 'smooth',
      })
    }
  }, [])

  const scrollToMessage = useCallback((
    messageId: string
  ): void => {
    const element = document.querySelector(`[data-message-id="${messageId}"]`)
    if (element && scrollContainerRef.current) {
      element.scrollIntoView({
        behavior: 'smooth',
        block: 'center',
      })
    }
  }, [])

  const clearError = useCallback((): void => {
    setError(null)
  }, [])

  return {
    // State
    messages,
    currentConversation,
    isSending,
    isTyping,
    typingUsers,
    
    // Actions
    sendMessage: handleSendMessage,
    editMessage: handleEditMessage,
    deleteMessage: handleDeleteMessage,
    loadMoreMessages: handleLoadMoreMessages,
    markMessagesAsRead: handleMarkMessagesAsRead,
    setCurrentConversation: handleSetCurrentConversation,
    
    // Typing
    startTyping: handleStartTyping,
    stopTyping: handleStopTyping,
    
    // Optimistic updates
    addOptimisticMessage,
    
    // UI helpers
    scrollToBottom,
    scrollToMessage,
    
    // Error handling
    error,
    clearError,
  }
}

// Utility hooks for specific chat functionality
export function useTypingIndicator(
  conversationId: string,
  enabled: boolean = true
): {
  isTyping: boolean
  startTyping: () => void
  stopTyping: () => void
} {
  const [isTyping, setIsTyping] = useState(false)
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  const startTyping = useCallback(() => {
    if (!enabled || isTyping) return
    
    setIsTyping(true)
    wsManager.sendTypingStart(conversationId)
    
    // Auto-stop typing after 3 seconds
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current)
    }
    
    typingTimeoutRef.current = setTimeout(() => {
      stopTyping()
    }, 3000)
  }, [conversationId, enabled, isTyping])

  const stopTyping = useCallback(() => {
    if (!isTyping) return
    
    setIsTyping(false)
    wsManager.sendTypingStop(conversationId)
    
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current)
      typingTimeoutRef.current = null
    }
  }, [conversationId, isTyping])

  useEffect(() => {
    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current)
      }
    }
  }, [])

  return {
    isTyping,
    startTyping,
    stopTyping,
  }
}

export function useMessageDelivery(
  messageId: string
): {
  isDelivered: boolean
  isSeen: boolean
  deliveryStatus: 'pending' | 'delivered' | 'seen' | 'failed'
} {
  // This would integrate with the store to track message delivery status
  // For now, return a basic implementation
  return {
    isDelivered: false,
    isSeen: false,
    deliveryStatus: 'pending',
  }
}

export function useChatPresence(
  conversationId: string
): {
  onlineUsers: string[]
  isUserOnline: (userId: string) => boolean
} {
  // This would integrate with WebSocket presence indicators
  // For now, return a basic implementation
  return {
    onlineUsers: [],
    isUserOnline: () => false,
  }
}

export default useChat
</content>
</write_to_file>

Now let me continue with the remaining Phase 8 files, starting with the core chat components:

<write_to_file>
<path>frontend/src/components/Chat/ChatWindow.tsx</path>
<content>
import React, { useState, useCallback, useRef, useEffect } from 'react'
import { useChat, useTypingIndicator } from '@/hooks/useChat'
import { MessageList } from './MessageList'
import { MessageInput } from './MessageInput'
import { TypingIndicator } from './TypingIndicator'
import { Conversation, MessageContentType } from '@/types'
import { useAppSelector } from '@/store'
import { selectIsMobile } from '@/store/slices/uiSlice'
import { clsx } from 'clsx'

interface ChatWindowProps {
  conversation: Conversation
  className?: string
  onClose?: () => void
  onMinimize?: () => void
  onMaximize?: () => void
  showHeader?: boolean
  showFooter?: boolean
  autoScroll?: boolean
  enableTyping?: boolean
  enableFileUpload?: boolean
  maxFileSize?: number
  acceptedFileTypes?: string[]
}

export const ChatWindow: React.FC<ChatWindowProps> = ({
  conversation,
  className,
  onClose,
  onMinimize,
  onMaximize,
  showHeader = true,
  showFooter = true,
  autoScroll = true,
  enableTyping = true,
  enableFileUpload = true,
  maxFileSize = 10 * 1024 * 1024, // 10MB
  acceptedFileTypes = ['image/*', 'text/*', 'application/pdf'],
}) => {
  const isMobile = useAppSelector(selectIsMobile)
  const scrollContainerRef = useRef<HTMLDivElement>(null)
  const [isAtBottom, setIsAtBottom] = useState(true)
  const [unreadCount, setUnreadCount] = useState(0)

  const {
    messages,
    currentConversation,
    isSending,
    isTyping,
    typingUsers,
    sendMessage,
    editMessage,
    deleteMessage,
    loadMoreMessages,
    markMessagesAsRead,
    addOptimisticMessage,
    scrollToBottom,
    scrollToMessage,
    error,
    clearError,
  } = useChat({
    conversationId: conversation.id,
    autoScroll,
    markAsReadOnVisible: true,
    enableTyping,
  })

  const { isTyping: localIsTyping, startTyping, stopTyping } = useTypingIndicator(
    conversation.id,
    enableTyping
  )

  // Monitor scroll position
  useEffect(() => {
    const container = scrollContainerRef.current
    if (!container) return

    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = container
      const atBottom = scrollHeight - scrollTop - clientHeight < 50
      setIsAtBottom(atBottom)
      
      // Load more messages when scrolling to top
      if (scrollTop < 100 && !isLoading) {
        loadMoreMessages()
      }
    }

    container.addEventListener('scroll', handleScroll)
    return () => container.removeEventListener('scroll', handleScroll)
  }, [loadMoreMessages])

  // Calculate unread messages when not at bottom
  useEffect(() => {
    if (isAtBottom) {
      setUnreadCount(0)
      return
    }

    const unreadMessages = messages.filter(message => 
      message.conversation_id === conversation.id &&
      message.sender_type !== 'user' &&
      !message.seen_at
    )

    setUnreadCount(unreadMessages.length)
  }, [messages, conversation.id, isAtBottom])

  const handleSendMessage = useCallback(async (
    content: string,
    contentType: MessageContentType = 'text',
    files?: File[]
  ) => {
    try {
      await sendMessage(content, contentType)
      
      // Handle file uploads if provided
      if (files && files.length > 0) {
        // File upload logic would be implemented here
        console.log('Files to upload:', files)
      }
      
      // Stop typing indicator
      stopTyping()
    } catch (error) {
      console.error('Failed to send message:', error)
    }
  }, [sendMessage, stopTyping])

  const handleMessageRetry = useCallback(async (messageId: string) => {
    const message = messages.find(m => m.id === messageId)
    if (message && message.failed_delivery) {
      // Retry sending the message
      await handleSendMessage(message.content, message.content_type as MessageContentType)
    }
  }, [messages, handleSendMessage])

  const handleScrollToBottom = useCallback(() => {
    scrollToBottom()
    setUnreadCount(0)
  }, [scrollToBottom])

  const handleInputFocus = useCallback(() => {
    startTyping()
  }, [startTyping])

  const handleInputBlur = useCallback(() => {
    stopTyping()
  }, [stopTyping])

  const handleInputChange = useCallback(() => {
    // Reset typing timeout
    startTyping()
  }, [startTyping])

  const handleLoadEarlier = useCallback(async () => {
    if (!isLoading && hasMoreMessages) {
      await loadMoreMessages()
    }
  }, [isLoading, hasMoreMessages, loadMoreMessages])

  const isLoading = !currentConversation || messages.length === 0

  return (
    <div className={clsx(
      'flex flex-col h-full bg-white dark:bg-gray-900 rounded-lg shadow-lg',
      'border border-gray-200 dark:border-gray-700',
      className
    )}>
      {/* Header */}
      {showHeader && (
        <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center space-x-3">
            <div className="flex-shrink-0">
              <div className="w-10 h-10 bg-primary-500 rounded-full flex items-center justify-center">
                <span className="text-white font-medium">
                  {conversation.title?.charAt(0).toUpperCase() || 'C'}
                </span>
              </div>
            </div>
            <div className="flex-1 min-w-0">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white truncate">
                {conversation.title || 'Conversation'}
              </h3>
              <p className="text-sm text-gray-500 dark:text-gray-400">
                {conversation.status === 'active' ? 'Active' : 'Inactive'}
                {typingUsers.length > 0 && (
                  <span className="ml-1">
                    â€¢ Someone is typing...
                  </span>
                )}
              </p>
            </div>
          </div>
          
          <div className="flex items-center space-x-2">
            {onMinimize && (
              <button
                onClick={onMinimize}
                className="p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800"
                aria-label="Minimize chat"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" />
                </svg>
              </button>
            )}
            
            {onMaximize && (
              <button
                onClick={onMaximize}
                className="p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800"
                aria-label="Maximize chat"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                </svg>
              </button>
            )}
            
            {onClose && (
              <button
                onClick={onClose}
                className="p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800"
                aria-label="Close chat"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            )}
          </div>
        </div>
      )}

      {/* Error Banner */}
      {error && (
        <div className="p-3 bg-red-50 dark:bg-red-900/20 border-b border-red-200 dark:border-red-800">
          <div className="flex items-center justify-between">
            <p className="text-sm text-red-600 dark:text-red-400">{error}</p>
            <button
              onClick={clearError}
              className="text-red-400 hover:text-red-600 dark:hover:text-red-300"
              aria-label="Clear error"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
      )}

      {/* Messages Container */}
      <div className="flex-1 overflow-hidden">
        <div 
          ref={scrollContainerRef}
          className="h-full overflow-y-auto overflow-x-hidden"
          role="log"
          aria-live="polite"
          aria-label="Chat messages"
        >
          {/* Load Earlier Messages */}
          {hasMoreMessages && (
            <div className="p-4 text-center">
              <button
                onClick={handleLoadEarlier}
                disabled={isLoading}
                className={clsx(
                  'px-4 py-2 text-sm font-medium rounded-lg transition-colors',
                  'bg-gray-100 hover:bg-gray-200 dark:bg-gray-800 dark:hover:bg-gray-700',
                  'text-gray-700 dark:text-gray-300',
                  'disabled:opacity-50 disabled:cursor-not-allowed'
                )}
              >
                {isLoading ? 'Loading...' : 'Load earlier messages'}
              </button>
            </div>
          )}

          {/* Messages List */}
          <MessageList
            messages={messages}
            conversation={conversation}
            onMessageEdit={editMessage}
            onMessageDelete={deleteMessage}
            onMessageRetry={handleMessageRetry}
            onScrollToMessage={scrollToMessage}
          />

          {/* Typing Indicator */}
          {typingUsers.length > 0 && (
            <TypingIndicator 
              typingUsers={typingUsers}
              className="p-4"
            />
          )}
        </div>
      </div>

      {/* Unread Messages Indicator */}
      {!isAtBottom && unreadCount > 0 && (
        <button
          onClick={handleScrollToBottom}
          className={clsx(
            'absolute bottom-20 left-1/2 transform -translate-x-1/2',
            'px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white',
            'rounded-full shadow-lg transition-all duration-200',
            'flex items-center space-x-2 text-sm font-medium'
          )}
          aria-label={`Scroll to bottom - ${unreadCount} unread messages`}
        >
          <span>{unreadCount} new message{unreadCount !== 1 ? 's' : ''}</span>
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 14l-7 7m0 0l-7-7m7 7V3" />
          </svg>
        </button>
      )}

      {/* Footer / Input Area */}
      {showFooter && (
        <div className="border-t border-gray-200 dark:border-gray-700 p-4">
          <MessageInput
            conversationId={conversation.id}
            onSendMessage={handleSendMessage}
            onFocus={handleInputFocus}
            onBlur={handleInputBlur}
            onChange={handleInputChange}
            disabled={isSending || conversation.status === 'resolved'}
            enableFileUpload={enableFileUpload}
            maxFileSize={maxFileSize}
            acceptedFileTypes={acceptedFileTypes}
            placeholder={isTyping ? 'Someone is typing...' : 'Type your message...'}
            aria-label="Message input"
          />
          
          {/* Typing Status */}
          {localIsTyping && (
            <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
              Typing...
            </div>
          )}
        </div>
      )}
    </div>
  )
}

ChatWindow.displayName = 'ChatWindow'
</content>
</write_to_file>

<write_to_file>
<path>frontend/src/components/Chat/MessageList.tsx</path>
<content>
import React, { useCallback, useMemo } from 'react'
import { Message, Conversation, MessageContentType } from '@/types'
import { format, isToday, isYesterday, formatDistanceToNow } from 'date-fns'
import { clsx } from 'clsx'

interface MessageListProps {
  messages: Message[]
  conversation: Conversation
  onMessageEdit: (messageId: string, newContent: string) => Promise<void>
  onMessageDelete: (messageId: string) => Promise<void>
  onMessageRetry: (messageId: string) => Promise<void>
  onScrollToMessage: (messageId: string) => void
  className?: string
}

export const MessageList: React.FC<MessageListProps> = ({
  messages,
  conversation,
  onMessageEdit,
  onMessageDelete,
  onMessageRetry,
  onScrollToMessage,
  className,
}) => {
  // Group messages by date
  const groupedMessages = useMemo(() => {
    const groups: Record<string, Message[]> = {}
    
    messages.forEach(message => {
      const date = new Date(message.created_at)
      const dateKey = format(date, 'yyyy-MM-dd')
      
      if (!groups[dateKey]) {
        groups[dateKey] = []
      }
      groups[dateKey].push(message)
    })
    
    return groups
  }, [messages])

  const formatMessageTime = useCallback((timestamp: string): string => {
    const date = new Date(timestamp)
    const now = new Date()
    
    if (isToday(date)) {
      return format(date, 'h:mm a')
    } else if (isYesterday(date)) {
      return `Yesterday ${format(date, 'h:mm a')}`
    } else if (date.getFullYear() === now.getFullYear()) {
      return format(date, 'MMM d, h:mm a')
    } else {
      return format(date, 'MMM d, yyyy, h:mm a')
    }
  }, [])

  const formatDateSeparator = useCallback((dateKey: string): string => {
    const date = new Date(dateKey)
    const now = new Date()
    
    if (isToday(date)) {
      return 'Today'
    } else if (isYesterday(date)) {
      return 'Yesterday'
    } else {
      return format(date, 'EEEE, MMMM d, yyyy')
    }
  }, [])

  const isMessageFromCurrentUser = useCallback((message: Message): boolean => {
    return message.sender_type === 'user'
  }, [])

  const getMessageStatus = useCallback((message: Message): 'sending' | 'sent' | 'delivered' | 'failed' => {
    if (message.failed_delivery) return 'failed'
    if (message.id.startsWith('optimistic-')) return 'sending'
    if (message.seen_at) return 'delivered'
    return 'sent'
  }, [])

  const renderMessageContent = useCallback((message: Message): React.ReactNode => {
    const { content, content_type, content_html, content_markdown } = message
    
    switch (content_type) {
      case 'html':
        return (
          <div 
            dangerouslySetInnerHTML={{ __html: content_html || content }} 
            className="prose prose-sm dark:prose-invert max-w-none"
          />
        )
      case 'markdown':
        return (
          <div className="prose prose-sm dark:prose-invert max-w-none whitespace-pre-wrap">
            {content_markdown || content}
          </div>
        )
      case 'code':
        return (
          <pre className="bg-gray-100 dark:bg-gray-800 p-3 rounded-lg overflow-x-auto text-sm">
            <code>{content}</code>
          </pre>
        )
      default:
        return (
          <div className="whitespace-pre-wrap break-words">
            {content}
          </div>
        )
    }
  }, [])

  const renderMessageAttachments = useCallback((message: Message): React.ReactNode => {
    if (!message.has_attachments || !message.attachments.length) return null
    
    return (
      <div className="mt-2 space-y-2">
        {message.attachments.map((attachment, index) => (
          <div
            key={index}
            className="inline-flex items-center space-x-2 p-2 bg-gray-100 dark:bg-gray-800 rounded-lg"
          >
            {attachment.type?.startsWith('image/') ? (
              <img
                src={attachment.url}
                alt={attachment.name}
                className="max-w-xs max-h-48 rounded-lg object-cover"
                loading="lazy"
              />
            ) : (
              <a
                href={attachment.url}
                download={attachment.name}
                className="flex items-center space-x-2 text-primary-600 dark:text-primary-400 hover:underline"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" />
                </svg>
                <span className="text-sm">{attachment.name}</span>
              </a>
            )}
          </div>
        ))}
      </div>
    )
  }, [])

  const renderMessageStatus = useCallback((message: Message): React.ReactNode => {
    const status = getMessageStatus(message)
    
    switch (status) {
      case 'sending':
        return (
          <div className="flex items-center space-x-1 text-gray-400 dark:text-gray-500">
            <svg className="w-3 h-3 animate-spin" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
            <span className="text-xs">Sending...</span>
          </div>
        )
      case 'failed':
        return (
          <div className="flex items-center space-x-1">
            <button
              onClick={() => onMessageRetry(message.id)}
              className="flex items-center space-x-1 text-red-500 hover:text-red-600 text-xs"
              aria-label="Retry sending message"
            >
              <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
              </svg>
              <span>Failed - Retry?</span>
            </button>
          </div>
        )
      case 'delivered':
        return (
          <svg className="w-3 h-3 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
          </svg>
        )
      default:
        return (
          <svg className="w-3 h-3 text-gray-400 dark:text-gray-500" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
          </svg>
        )
    }
  }, [getMessageStatus, onMessageRetry])

  const renderQuickReplies = useCallback((message: Message): React.ReactNode => {
    if (!message.quick_replies || !message.quick_replies.length) return null
    
    return (
      <div className="mt-3 flex flex-wrap gap-2">
        {message.quick_replies.map((reply, index) => (
          <button
            key={index}
            onClick={() => {
              // Handle quick reply click
              console.log('Quick reply clicked:', reply)
            }}
            className="px-3 py-1 text-sm bg-primary-100 hover:bg-primary-200 dark:bg-primary-900 dark:hover:bg-primary-800 text-primary-700 dark:text-primary-300 rounded-full transition-colors"
          >
            {reply.text || reply.title}
          </button>
        ))}
      </div>
    )
  }, [])

  return (
    <div className={clsx('space-y-4', className)} role="log" aria-label="Chat messages">
      {Object.entries(groupedMessages).map(([dateKey, dayMessages]) => (
        <div key={dateKey}>
          {/* Date Separator */}
          <div className="relative my-6">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300 dark:border-gray-600" />
            </div>
            <div className="relative flex justify-center">
              <span className="px-3 bg-white dark:bg-gray-900 text-sm text-gray-500 dark:text-gray-400 font-medium">
                {formatDateSeparator(dateKey)}
              </span>
            </div>
          </div>

          {/* Messages for this date */}
          <div className="space-y-4">
            {dayMessages.map((message) => {
              const isCurrentUser = isMessageFromCurrentUser(message)
              const messageStatus = getMessageStatus(message)

              return (
                <div
                  key={message.id}
                  data-message-id={message.id}
                  className={clsx(
                    'flex',
                    isCurrentUser ? 'justify-end' : 'justify-start',
                    message.failed_delivery && 'opacity-75'
                  )}
                >
                  <div
                    className={clsx(
                      'max-w-[70%] lg:max-w-[60%] rounded-lg px-4 py-2',
                      'shadow-sm',
                      isCurrentUser
                        ? 'bg-primary-500 text-white'
                        : 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100'
                    )}
                  >
                    {/* Message Content */}
                    <div className="text-sm">
                      {renderMessageContent(message)}
                    </div>

                    {/* Attachments */}
                    {renderMessageAttachments(message)}

                    {/* Quick Replies */}
                    {!isCurrentUser && renderQuickReplies(message)}

                    {/* Message Metadata */}
                    <div className={clsx(
                      'flex items-center justify-between mt-2',
                      'text-xs',
                      isCurrentUser ? 'text-primary-100' : 'text-gray-500 dark:text-gray-400'
                    )}>
                      <time 
                        dateTime={message.created_at}
                        className="flex-shrink-0"
                        title={new Date(message.created_at).toLocaleString()}
                      >
                        {formatMessageTime(message.created_at)}
                      </time>
                      
                      {isCurrentUser && (
                        <div className="flex items-center space-x-1 ml-2">
                          {renderMessageStatus(message)}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )
            })}
          </div>
        </div>
      ))}

      {messages.length === 0 && (
        <div className="text-center py-12">
          <div className="text-gray-500 dark:text-gray-400">
            <svg className="w-12 h-12 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
            </svg>
            <p className="text-sm">No messages yet. Start the conversation!</p>
          </div>
        </div>
      )}
    </div>
  )
}

MessageList.displayName = 'MessageList'
</content>
</write_to_file>

Let me continue with the remaining chat components:

<write_to_file>
<path>frontend/src/components/Chat/MessageInput.tsx</path>
<content>
import React, { useState, useRef, useCallback, KeyboardEvent, ChangeEvent, DragEvent } from 'react'
import { MessageContentType } from '@/types'
import { clsx } from 'clsx'
import toast from 'react-hot-toast'

interface MessageInputProps {
  conversationId: string
  onSendMessage: (content: string, contentType?: MessageContentType, files?: File[]) => void
  onFocus?: () => void
  onBlur?: () => void
  onChange?: (value: string) => void
  disabled?: boolean
  placeholder?: string
  maxLength?: number
  enableFileUpload?: boolean
  maxFileSize?: number
  acceptedFileTypes?: string[]
  className?: string
  ariaLabel?: string
}

interface FileUploadState {
  files: File[]
  isDragging: boolean
  isUploading: boolean
  uploadProgress: number
}

export const MessageInput: React.FC<MessageInputProps> = ({
  conversationId,
  onSendMessage,
  onFocus,
  onBlur,
  onChange,
  disabled = false,
  placeholder = 'Type your message...',
  maxLength = 4000,
  enableFileUpload = true,
  maxFileSize = 10 * 102
